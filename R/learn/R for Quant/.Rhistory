install.packages("pso")
library()
.libPaths()
.libPaths()
library()
install.packages("pso")
set.seed(1)
library(pso)
psoptim(rep(NA, 2), function(x){20+sum(x^2-10*cos(2*pi*x))}, lower = -5, upper = 5, control = list(abstol = 1e-8))
x = seq(from = -10, to = 10, 1000)
x
x <- seq(from = -10, to = 10, by = 0.01)
y <- 20+sum(x^2-10*cos(2*pi*x))
y
y <- 20 + x^2-10*cos(2*pi*x)
y
plot(x, y)
x <- 2
20+sum(x^2-10*cos(2*pi*x))
20+x^2-10*cos(2*pi*x)
x <- seq(from = -5, to = 5, by = 0.01)
y <- 20 + x^2-10*cos(2*pi*x)
y
plot(x, y)
psoptim(rep(NA, 2), function(x){20+sum(x^2-10*cos(2*pi*x))}, lower = -5, upper = 5, control = list(abstol = 1e-8))
setwd("C:/Users/ylc/nutstore/R-work/learn/R for Quant")
V0 <- 100   #初始自然价值
nu <- 0.1   #漂移项
sigma <- 0.2   #波动率参数
dt <- 1/252   #delta t的长度
Time <- 1   #时间周期的终点
M <- Time/dt   #时间周期的个数
n <- 10000   #生成轨线的个数
#为了产生过程V的对数增量，需要从正态分布中使用指定的均值和标准差生成n*M个随机数
set.seed(117)
val <- rnorm(n*M, mean = (nu-sigma^2/2)*dt, sd = sigma*dt^0.5)
dlnV <- matrix(val, M, n)
#为了及时得到公司价值的变化，需要汇总增量的对数
V <- V0*exp(apply(dlnV, 2, cumsum))
#画出前5条轨线
matplot(x = seq(0+dt, Time, dt), y = V[, 1:500], type = 's', lty = 1, xlab = 'Time', ylab = 'Firm value trajectories', main = 'Trajectories of firm values in the Merton model')
r <- 0.05   #无风险利率
K <- 80   #债务面值
D <- exp(-r*Time)*mean((pmin(V[M, ], K)))    #风险债务值
D
matplot(x = seq(0+dt, Time, dt), y = V[, 1:50], type = 's', lty = 1, xlab = 'Time', ylab = 'Firm value trajectories', main = 'Trajectories of firm values in the Merton model')
V0 <- 100   #初始自然价值
nu <- 0.1   #漂移项
sigma <- 0.2   #波动率参数
dt <- 1/252   #delta t的长度
Time <- 1   #时间周期的终点
M <- Time/dt   #时间周期的个数
n <- 10000   #生成轨线的个数
#为了产生过程V的对数增量，需要从正态分布中使用指定的均值和标准差生成n*M个随机数
set.seed(117)
val <- rnorm(n*M, mean = (nu-sigma^2/2)*dt, sd = sigma*dt^0.5)
dlnV <- matrix(val, M, n)
#为了及时得到公司价值的变化，需要汇总增量的对数
V <- V0*exp(apply(dlnV, 2, cumsum))
#画出前50条轨线
matplot(x = seq(0+dt, Time, dt), y = V[, 1:50], type = 's', lty = 1, xlab = 'Time', ylab = 'Firm value trajectories', main = 'Trajectories of firm values in the Merton model')
r <- 0.05   #无风险利率
K <- 80   #债务面值
D <- exp(-r*Time)*mean((pmin(V[M, ], K)))    #风险债务值
D
library(fOptions)
V0 - GBSOption(TypeFlag = "c", S = V0, X = K, Time = Time, r = r, b = r, sigma = sigma)@price
Time <- seq(0.1, 10, 0.1)
D <- V0- GBSOption(TypeFlag = "c", S = V0, X = K, Time = Time, r = r, b = r, sigma = sigma)@price
creditspreads <- 1/Time*log(K/D)-r
matplot(x = Time, y = creditspreads, type = 'l', xlab = 'Maturity', ylab = 'Credit spreads', main = 'Term structure of credit spreads in the Mertion model')   #信用价差曲线
install.packages("sde")
library(sde)
Time <- 1   #时间周期终点
dt <- 1/252   #时间周期长度
M <- Time/dt   #时间周期个数
#创建CIR过程，声明初始值X0,漂移率参数theta1和theta2（theta1/theta2是长期值，theta2是调整的速度），以及波动率参数Theta3
lambda <- sde.sim(X0 = 0.1, delta = dt, T = Time, N = M, theta = c(0.05, 0.5, 0.2), model = "CIR")
n <- 5
set.seed(117)
val <- rpois(n*(M+1), lambda)
dN <- matrix(val, M+1, n)
N <- apply(dN, 2, cumsum)
matplot(x = seq(0, Time, dt), y = N[, 1:5], type = "s", xlab = "Time", ylab = "'Numver of defaults’ process trajectories", main = "Trajectories of Cox processes")
library(sde)
Time <- 1   #时间周期终点
dt <- 1/252   #时间周期长度
M <- Time/dt   #时间周期个数
#创建CIR过程，声明初始值X0,漂移率参数theta1和theta2（theta1/theta2是长期值，theta2是调整的速度），以及波动率参数Theta3
lambda <- sde.sim(X0 = 0.1, delta = dt, T = Time, N = M, theta = c(0.05, 0.5, 0.2), model = "CIR")
n <- 5
set.seed(117)
val <- rpois(n*(M+1), lambda)
dN <- matrix(val, M+1, n)
N <- apply(dN, 2, cumsum)
matplot(x = seq(0, Time, dt), y = N[, 1:5], type = "s", xlab = "Time", ylab = "'Numver of defaults’ process trajectories", main = "Trajectories of Cox processes")
#相关违约——投资组合方法
library(copula)
norm.cop <- normalCopula(0.7)   #声明一个相关系数为0.7的高斯copula类
#生成两个随机变量的500个实现，这两个随机变量服从高斯copula相依性结构的均匀分布
set.seed(117)
u1 <- rCopula(500, norm.cop)
t.cop <- tCopula(0.7, df = 4)   #为了比较，定义一个相关系数为0.7自由度为4的tcopula类
set.seed(117)
u2 <- rCopula(500, t.cop)   #生成服从t-copula相依性的成对随机变量的500个实现
par(mfcol = c(1, 2))
plot(u1, main = "Scatter graphs of random variable pairs generated by Gaussian copula")
plot(u2, main = 'Scatter graphs of random variable pairs generated by t-copula')
par(mfcol = c(1, 1))
fit.ml <- fitCopula(norm.cop, u1, method = 'ml')
fit.ml
install.packages("copula")
#相关违约——投资组合方法
library(copula)
norm.cop <- normalCopula(0.7)   #声明一个相关系数为0.7的高斯copula类
#生成两个随机变量的500个实现，这两个随机变量服从高斯copula相依性结构的均匀分布
set.seed(117)
u1 <- rCopula(500, norm.cop)
t.cop <- tCopula(0.7, df = 4)   #为了比较，定义一个相关系数为0.7自由度为4的tcopula类
set.seed(117)
u2 <- rCopula(500, t.cop)   #生成服从t-copula相依性的成对随机变量的500个实现
par(mfcol = c(1, 2))
plot(u1, main = "Scatter graphs of random variable pairs generated by Gaussian copula")
plot(u2, main = 'Scatter graphs of random variable pairs generated by t-copula')
par(mfcol = c(1, 1))
fit.ml <- fitCopula(norm.cop, u1, method = 'ml')
fit.ml
install.packages("CreditMetrics")
library(CreditMetrics)
lgd <- 0.5
rc <- c("A", "B", "D")
M <- matrix(c(85, 13, 2, 5, 80, 15, 0, 0, 100)/100, 3, 3, dimnames = list(rc, rc), byrow = TRUE)
cm.cs(M, lgd)   #从迁移矩阵计算信用价差
install.packages("evir")
library(evir)
data(danish)   #载入evir包中的danish数据
help(danish)
summary(danish)
hist(danish, breaks = 200, xlim = c(0, 20))
emplot(danish)   #x轴使用对数尺度
emplot(danish, alog = "xy")
qplot(danish, trim = 100)   #创建QQ图
meplot(danish, omit = 4)
gpdfit <- gpd(danish, threshold = 10)   #拟合一个GPD分布
gpdfit$par.ses
tp <- tailplot(gpdfit)
tp <- tailplot(gpdfit)   #直接创建一个原始的丹麦火灾损失分布的尾部图形
gpd.q(tp, pp = 0.999, ci.p = 0.95)
quantile(danish, probs = 0.999, type = 1)
tp <- tailplot(gpdfit)
gpd.q(tp, pp = 0.99)
gpd.sfall(tp, 0.99)
set.seed(7)
e <- erdos.renyi.game(100, 0.1)
install.packages("igraph")
library(igraph)
set.seed(7)
e <- erdos.renyi.game(100, 0.1)
e <- erdos.renyi.game(100, 0.1)   #仿真一个erdos-renyi图，设置节点数以及在两个任意节点之间划出一条边的概率
plot(e)
average.path.length(e)   #计算平均路径长度
set.seed(592)
w <- watts.strogatz.game(1, 100, 5, 0.05)   #创建一个随机的无标度网络
plot(w)
graph.density(w)   #计算密度
transitivity(w)   #计算聚类（传递性）
average.path.length(w)   #计算平均路径长度
data <- read.csv("networktable.csv")
data <- read.table("networktable.csv", sep = ";", header = TRUE)
View(data)
str(data)
data$Amount <- gsub(",", ".", data$Amount)
str(data)
data$Amount <- as.numeric(gsub(",", ".", data$Amount))
data$Interest <- as.numeric((gsub(",", ".", data$Interest)))
write.csv(data, "networktable.csv")
data <- read.csv("networktable.csv")
size <- read.csv2("vertices.csv")
View(size)
size <- read.csv("vertices.csv")
size <- read.csv2("vertices.csv")
bignetwork <- graph.data.frame(data, vertices = size)
bignetwork <- graph.data.frame(data, vertices = size)
data <- read.csv("networktable.csv")
size <- read.csv2("vertices.csv")
bignetwork <- graph.data.frame(data, vertices = size)
is.connected(bignetwork)
table(is.multiple(bignetwork))   #检查这个网络的边是否是多重的
str(is.loop(bignetwork))   #检查这个网络是否存在环
snetwork <- simplify(bignetwork, edge.attr.comb = "sum")
plot(snetwork, edge.arrow.size = 0.4)
communities(bignetwork)
communities
communities(bignetwork)
walktrap.community(bignetwork)
monthlynetwork <- subset(data, (Year == 2008) & (Month == 9))
monthlynetwork
mAmount <- with(data, aggregate(Amount, by = list(Month = Month, Year = Year), Fun = mean))
mAmount <- with(data, aggregate(Amount, by = list(Month = Month, Year = Year), FUN = mean))
plot(ts(mAmount$x, start = c(2007, 1), frequency = 12), ylab = "Amount")
View(mAmount)
View(data)
ds <- sapply(2007:2010, function(year){
sapply(1:12, function(mount){
mdata <- subset(data, (Year == Year)&(Month == Month))
graph.density(graph.data.frame(mdata))
})
})
plot(ts(as.vector(ds), start = c(2007, 1), frequency = 12))
abline(v = 2008 + 259/366, col = "red")
g <- graph.data.frame(data)
degree <- degree(g, normalized = TRUE)
between <- betweenness(g, normalized = TRUE)
closeness <- closeness(g, normalized = TRUE)
eigenv <- evcent(g, directed = TRUE)$vector
norm <- function(x) x/mean(x)
index <- (norm(degree) + norm(between) + norm(closeness) + norm(eigenv)) / 4
hist(index)
